# Plants_VS_Zombies
В корне лежит версия под Windows, в папке - версия под Linux

Это аналог игры Plants_Vs_Zombies.

Главное концептуальное отличие от классической игры в том, что мы можем играть не только за растений, но и за животных, которые так же охраняют свой дом.

В игре есть две фракции, которые имеют одинаковый набор юнитов с незначительными различиями(картинка). В частности, есть следующие юниты: Shoot(стрелящий горох или стреляющая морская свинка), EnergyGenerator(производитель энергии: подсолнечник или валяющийся кот), Wall(стоящая и защищая картоха или собака), Hit(Дерущаяся капуста или кролик), Mine(Нечто взрывающееся). Таким образом, хранение всех юнитов организовано так: есть базовый класс и от него унаследованы по классу для каждого типа юнитов(типов столько, сколько принципиально различных инструкций для объекта).

Для создания подобных юнитов лучше всего подходит абстрактная фабрика, которая была реализована. У данного решения следующие плюсы: легко добавлять новый вид юнита; гарантируется, что все созданные объекты принадлежат одной фракции; легко поддерживать код. Главный минус фабрики, а именно сложность добавления новых фракций нивелируется тем, что в данной модели сложно придумать новые фракции для расширения игры.

Для удобства при модификации кода использовано следующее решение. Есть абстрактный класс AbstractClassProperties и унаследованнные от него классы свойств каждого объекта. Предполагается хранить в объектах этих классов характеристики, по которым можно создавать объект. То есть, каждый юнит имеет некие характеристики. Shoot(power - урон от пули, speed - скорость пули, interval - интервал выстрела), Wall(timeToEat - время на съедание) и так далее. И логично, что в процессе развития в игре, пользователю доступны все более сильные и сильные персонажи. Чтобы не привязываться к классу юнита, все подобные параметры хранятся в переменной класса ConcreteProperties. Таким образом, изменение характеристик не затрагивает сам класс юнита, что есть очень хорошо. Юнит как раз таки умеет конструироваться от своих хаактеристик. Собственно, в фабрике можно сделать конструирование как раз от Properties. Но для облегчения демонстрациии я ввел формальные уровни, для кажждого из которых по формуле (которую легко модифицировать из-за выноса в метод) вычисляются свойства и уже от них конструируется объект. То есть данная фабрика создает разной силы объекты в зависимоти от запрошенного уровня.

Для демонстарации создан класс Field, в котором хранятся ячейки для объектов. К этому классу применен singleton для того, чтобы в игре было всегда лишь одно поле. Собственно, для демонстрации же, в Юните пристутствуют несколько полей и методов, выводящих характеристики в консоль.

Демонстрация работает следующим образом. Сначала вводится 0 или 1 для выбора фракции. Затем отрисовывается поле, на которое можно добавлять объекты посредством ввода строки "X Y TYPE LEVEL", без кавычек - координаты в нумерации с нуля, тип объекта и его уровень. Формат взаимодействия прописан еще и в консоли при запуске.

-------------------------------------------------------------------------------------------------------------------------------------------

2-ое задание

Теперь в клетке поля может находиться не только юнит, но и их объединение. Юниты объединяются в отряды. Отряды объединяются в армии. Любая из этих трех сущностей воспринимается как один объект и может находиться в клетке. Для этого используется паттерн компоновщик. Мы вводим некую абстракцию компонент, которая либо лист, либо список сыновей. В первом случае, объект сам выполняет запрошенную функцию, во втором дилегирует сыновям. 

Каждая компонента(армия/отряд/сущность) атакует так, что по очередности атакуют сначала все юниты первого заданного типа, потом второго заданного и так далее. Так же компонента имеет экономический режим. В этом режиме производится одна итерация атаки, после чего юниты занимаются развитием. Для добавления подобного функционала используется паттерн декоратор. Есть абстрактный класс декоратор (унаследованный от абстрактного компонента), в котором есть поле-указатель на абстрактный компонент(либо на декоратор, либо на компонент). Первый конкретный декоратор - шаблонный класс декоратора конкретного типа юнитов. С его помощью производится вызов тех или ииных типов юнитов в заданном пользователем порядке. Собственно, вызываемый метод сначала передает обязанности по указателю на абстрактный компонент(либо на декоратор, либо на компонент), а затем вызывает атаку конкретного типа юнитов. Что касается экономическог декоратора, то он работает аналогично: его метод сначала вызывает функционал хранящегося там указателя на компонент(считаем, что если к компоненту применен экономический декоратор, то других декораторов не примененено), а затем выполняет экономическое развитие.

P.S. В данной игре экономический декоратор совсем не нужен и не к месту. Он использован лишь для того, чтобы показать умение писать декоратор и показать, что декоратор просто добавляет некий функционал к уже имеющемуся базовому функционалу компонента.

Для того, чтобы в клетку поля можно было поместить компоненту используется адаптер, который предоставляет доступ к компоненте с использованием известного юниту интерфейса. То есть, это класс, унаследованный от абстрактного юнита, в котором есть указатель на компонент и определены все необходимые методы.

P.P.S. Здесь можно обойтись и без адаптера, если унаследовать абстрактный компонент от абстрактного юнита. Написанные интерфейсы совпадают. Но использован адаптер, чтобы 1) показать умение его использовать, 2) иметь свободу в определении дальнейших судеб интерфейсов абстрактных класса юнита и класса компонент 3) все-таки логически и структурно, компонент - не юнит, у юнита есть обязательные поля, не обязательно присущие компоненту. Чтобы не нарушать логику программы лучше не использовать такое прмямое наследование.

P.P.P.S Прошу прощения за то, что вторая диаграмма выглядит страшненько и нарисована отдельно. Дело в том, что блокируя инстаграм, власти заблокировали онлайн-рисовалку, в которой у меня хранилась первая часть схемы, пришлось рисовать вторую как и где получится.

Можно запустить демонстрацию второго задания, в которой создается юнит/отряд/армия и затем применяются те или иные декораторы и выполняется действие с этими примененными декораторами. Варианты декораторов: пустой, экономический, последоватльность декораторов конкретных типов юнитов для задания порядка действия различных типов юнитов
